// Prisma schema for RestoBill

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Bill {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  // Zahler Info
  payerName     String
  paypalHandle  String? // z.B. "maxmustermann" f√ºr paypal.me/maxmustermann (optional)

  // Rechnung
  imageUrl       String
  restaurantName String?
  totalAmount    Float?

  // Google Places Integration
  restaurantAddress String? // Vollst√§ndige Adresse vom Beleg
  googlePlaceId     String? // Google Place ID (eindeutig)
  googleMapsUrl     String? // Google Maps Link zum Restaurant
  reviewUrl         String? // Review-Link f√ºr G√§ste (https://search.google.com/local/writereview?placeid=...)

  // Relations
  items      BillItem[]
  selections Selection[]
  feedback   RestaurantFeedback[]

  // Public Link Token
  shareToken String @unique @default(uuid())

  @@index([shareToken])
  @@index([googlePlaceId])
}

model BillItem {
  id     String @id @default(uuid())
  billId String
  bill   Bill   @relation(fields: [billId], references: [id], onDelete: Cascade)

  name         String // z.B. "Pizza Margherita"
  quantity     Int // z.B. 2
  pricePerUnit Float // z.B. 12.50
  totalPrice   Float // quantity * pricePerUnit
  position     Int @default(0) // Position auf der Rechnung (0 = erste Position)

  @@index([billId])
  @@index([billId, position]) // Sortierung nach Position
}

enum PaymentMethod {
  PAYPAL
  CASH
}

enum SelectionStatus {
  SELECTING // Live tracking - Guest is selecting items (blue badge)
  PAID      // Final payment - Guest has paid (green badge)
}

model Selection {
  id        String  @id @default(uuid())
  billId    String
  bill      Bill    @relation(fields: [billId], references: [id], onDelete: Cascade)

  sessionId  String // Required - unique browser session identifier
  friendName String // Display name

  // Quantity multiplier for each item (0.5x, 1x, 2x etc)
  // Stored as JSON: {"itemId": quantity}
  // Updated in real-time during SELECTING status
  itemQuantities Json? // z.B. {"item-uuid-1": 0.5, "item-uuid-2": 1}

  // Selection Status (NEW)
  status SelectionStatus @default(SELECTING)

  // Trinkgeld (only set when status=PAID)
  tipAmount Float @default(0)

  // Zahlungsmethode (only set when status=PAID, null during SELECTING)
  paymentMethod PaymentMethod?

  // Payment Status (legacy compatibility)
  paid   Boolean   @default(false)
  paidAt DateTime?

  // Auto-cleanup for abandoned selections
  expiresAt DateTime // Cleanup after 30 days (changed from 30 minutes)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Note: Unique constraint removed to allow multiple payments per guest
  // Partial unique index created via SQL: unique(billId, sessionId) WHERE status='SELECTING'
  // This allows: only one SELECTING per session, but multiple PAID per session
  @@index([billId])
  @@index([sessionId])
  @@index([status])
  @@index([expiresAt])
  @@index([billId, sessionId]) // Composite index for lookups
}

// Restaurant Feedback Model
// Stores feedback from guests - either Google review redirect or personal feedback
model RestaurantFeedback {
  id        String   @id @default(uuid())
  billId    String
  bill      Bill     @relation(fields: [billId], references: [id], onDelete: Cascade)

  sessionId  String  // Browser session (identifies guest)
  friendName String? // Optional name of guest

  // Rating: 1=schlecht (üòû), 2=mittel (üòê), 3=top (üòä)
  rating Int

  // Personal feedback (only for rating 1 or 2, null for rating 3)
  feedbackText String?

  createdAt DateTime @default(now())

  @@index([billId])
  @@index([sessionId])
  @@index([rating])
}
